
static const char* kPool_js= "\n(function createPool(n,tagg){'use strict';tagg=this;n=Math.floor(n);if(!(n>0)){throw'.createPool( numOfThreads ): numOfThreads must be a Number > 0';}\nvar kTypeRun=1;var kTypeEmit=2;var pool=[];var idleThreads=[];var q={first:null,last:null,length:0};var poolObject={any:{eval:evalAny,emit:emitAny},all:{eval:evalAll,emit:emitAll},on:on,totalThreads:function getTotalThreads(){return pool.length},idleThreads:function getIdleThreads(){return idleThreads.length},pendingJobs:function getPendingJobs(){return q.length},destroy:destroy,load:poolLoad};try{while(n--){pool[n]=idleThreads[n]=tagg.create();}}\ncatch(e){destroy(1);throw e;}\nfunction poolLoad(path,cb){pool.forEach(function(v,i,o){v.load(path,cb)});return poolObject;}\nfunction nextJob(t){var job=qPull();if(job){if(job.type===kTypeRun){t.eval(job.srcTextOrEventType,function idleCB(e,d){nextJob(t);var f=job.cbOrData;if(f){job.cbOrData.call(t,e,d);}});}\nelse if(job.type===kTypeEmit){t.emit(job.srcTextOrEventType,job.cbOrData);nextJob(t);}}\nelse{idleThreads.push(t);}}\nfunction qPush(srcTextOrEventType,cbOrData,type){var job={next:null,srcTextOrEventType:srcTextOrEventType,cbOrData:cbOrData,type:type};if(q.last){q.last.next=job;q.last=job;}\nelse{q.first=q.last=job;}\nq.length++;}\nfunction qPull(){var job=q.first;if(job){if(q.last===job){q.first=q.last=null;}\nelse{q.first=job.next;}\nq.length--;}\nreturn job;}\nfunction cbWrap(thread,cb){return function wrappedCb(){};}\nfunction evalAny(src,cb){if(idleThreads.length)\nidleThreads.pop().eval(src,cbWrap(cb));else\njobsQueueAny.push({type:kTypeRun,src:src,cb:cb});return poolObject;}\nfunction evalAll(src,cb){pool.forEach(function(v,i,o){v.eval(src,cb)});return poolObject;}\nfunction emitAny(t,args){args=Array.prototype.splice.call(arguments,0);if(idleThreads.length)\n(t=idleThreads.pop()).emit.apply(t,args);else\njobsQueueAny.push({type:kTypeEmit,args:args});return poolObject;}\nfunction emitAll(args){args=Array.prototype.splice.call(arguments,0);pool.forEach(function(v,i,o){v.emit.apply(v,args)});return poolObject;}\nfunction on(event,cb){pool.forEach(function(v,i,o){v.on(event,cb)});return poolObject;}\nfunction destroy(rudely){function err(){throw'This thread pool has been destroyed';}\nfunction beNice(){if(q.length){setTimeout(beNice,666);}\nelse{beRude();}}\nfunction beRude(){q.length=0;q.first=null;pool.forEach(function(v,i,o){v.destroy();});poolObject.eval=poolObject.totalThreads=poolObject.idleThreads=poolObject.pendingJobs=poolObject.destroy=err;}\nrudely?beRude():beNice();}\nreturn poolObject;})\n";
